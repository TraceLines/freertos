
## 任务行的流程——同步实现
1. 因为任务2先创建，所以先执行任务2，进入任务2后，去读取队列，此时队列中并没有数据，则任务2被阻塞。
2. 调度器开始调度任务1来执行，在任务1里，不断执行这个for循环（其实也不是只有它一个任务执行，还有一个空闲任务参与其中。但空闲任务会让度，在任务就绪队列里，就只有任务1在执行。）任务1不断进行for循环
3. 之前设置读取队列的等待时间为500，这个值应该是tick或什么，与任务1中完成for循环的10000000相比，远远不够，导致没有等到队列中的数据就退出了等待，导致任务2重新进入就绪列表中，参与任务的轮循。
4. 而对任务1来说，任务调度器调度任务时，会保存现场，而任务1的现场永远是在自加中。在自加到10000000次之前，队列中的值，就是要写的那个sum值，还没有写进去，所以从已经参与任务调度的任务2中读这个数据（其实也不是读，是再次进入读队列不成功，然后阻塞）
5. 之所以偶尔能打印出来sum的值为0，是任务调试现场，然后返回现场时实现的。
6. 当把数据从队列中读出来之后，则队列为空，再次读取，则失败，任务2进入阻塞状态
7. 这里有一个奇怪的地方，就是读取失败后，应该立即进入阻塞状态，不应该再运行了，但根据串口打印出来的信息，任务2还在循环中运行。（这个还应该归于阻塞时间设置的问题，阻塞时间到了，返回任务时的高度。当设置了portMAX_DELAY后，任务2除非被唤醒，否则不会再出现了。）